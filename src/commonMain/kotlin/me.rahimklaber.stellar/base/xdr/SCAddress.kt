// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * SCAddress's original definition in the XDR file is:
 * ```
 * union SCAddress switch (SCAddressType type)
{
case SC_ADDRESS_TYPE_ACCOUNT:
AccountID accountId;
case SC_ADDRESS_TYPE_CONTRACT:
Hash contractId;
case SC_ADDRESS_TYPE_MUXED_ACCOUNT:
MuxedEd25519Account muxedAccount;
case SC_ADDRESS_TYPE_CLAIMABLE_BALANCE:
ClaimableBalanceID claimableBalanceId;
case SC_ADDRESS_TYPE_LIQUIDITY_POOL:
PoolID liquidityPoolId;
};
 * ```
 */
sealed class SCAddress(val type: SCAddressType) : XdrElement {
    fun accountIdOrNull(): Account? = if (this is Account) this else null
    data class Account(
        val accountId: AccountID,
    ) : SCAddress(SCAddressType.SC_ADDRESS_TYPE_ACCOUNT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            accountId.encode(stream)
        }
    }

    fun contractIdOrNull(): Contract? = if (this is Contract) this else null
    data class Contract(
        val contractId: Hash,
    ) : SCAddress(SCAddressType.SC_ADDRESS_TYPE_CONTRACT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            contractId.encode(stream)
        }
    }

    fun muxedAccountOrNull(): MuxedAccount? = if (this is MuxedAccount) this else null
    data class MuxedAccount(
        val muxedAccount: MuxedEd25519Account,
    ) : SCAddress(SCAddressType.SC_ADDRESS_TYPE_MUXED_ACCOUNT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            muxedAccount.encode(stream)
        }
    }

    fun claimableBalanceIdOrNull(): ClaimableBalance? = if (this is ClaimableBalance) this else null
    data class ClaimableBalance(
        val claimableBalanceId: ClaimableBalanceID,
    ) : SCAddress(SCAddressType.SC_ADDRESS_TYPE_CLAIMABLE_BALANCE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            claimableBalanceId.encode(stream)
        }
    }

    fun liquidityPoolIdOrNull(): LiquidityPool? = if (this is LiquidityPool) this else null
    data class LiquidityPool(
        val liquidityPoolId: PoolID,
    ) : SCAddress(SCAddressType.SC_ADDRESS_TYPE_LIQUIDITY_POOL) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            liquidityPoolId.encode(stream)
        }
    }

    companion object : XdrElementDecoder<SCAddress> {
        override fun decode(stream: XdrInputStream): SCAddress {
            return when (val type = SCAddressType.decode(stream)) {
                SCAddressType.SC_ADDRESS_TYPE_ACCOUNT -> {
                    val accountId = AccountID.decode(stream)
                    Account(accountId)
                }

                SCAddressType.SC_ADDRESS_TYPE_CONTRACT -> {
                    val contractId = Hash.decode(stream)
                    Contract(contractId)
                }

                SCAddressType.SC_ADDRESS_TYPE_MUXED_ACCOUNT -> {
                    val muxedAccount = MuxedEd25519Account.decode(stream)
                    MuxedAccount(muxedAccount)
                }

                SCAddressType.SC_ADDRESS_TYPE_CLAIMABLE_BALANCE -> {
                    val claimableBalanceId = ClaimableBalanceID.decode(stream)
                    ClaimableBalance(claimableBalanceId)
                }

                SCAddressType.SC_ADDRESS_TYPE_LIQUIDITY_POOL -> {
                    val liquidityPoolId = PoolID.decode(stream)
                    LiquidityPool(liquidityPoolId)
                }

                else -> throw IllegalArgumentException("unknown type: $type")
            }
        }
    }
}
