// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * StellarMessage's original definition in the XDR file is:
 * ```
 * union StellarMessage switch (MessageType type)
{
case ERROR_MSG:
Error error;
case HELLO:
Hello hello;
case AUTH:
Auth auth;
case DONT_HAVE:
DontHave dontHave;
case PEERS:
PeerAddress peers<100>;

case GET_TX_SET:
uint256 txSetHash;
case TX_SET:
TransactionSet txSet;
case GENERALIZED_TX_SET:
GeneralizedTransactionSet generalizedTxSet;

case TRANSACTION:
TransactionEnvelope transaction;

case TIME_SLICED_SURVEY_REQUEST:
SignedTimeSlicedSurveyRequestMessage signedTimeSlicedSurveyRequestMessage;

case TIME_SLICED_SURVEY_RESPONSE:
SignedTimeSlicedSurveyResponseMessage signedTimeSlicedSurveyResponseMessage;

case TIME_SLICED_SURVEY_START_COLLECTING:
SignedTimeSlicedSurveyStartCollectingMessage
signedTimeSlicedSurveyStartCollectingMessage;

case TIME_SLICED_SURVEY_STOP_COLLECTING:
SignedTimeSlicedSurveyStopCollectingMessage
signedTimeSlicedSurveyStopCollectingMessage;

// SCP
case GET_SCP_QUORUMSET:
uint256 qSetHash;
case SCP_QUORUMSET:
SCPQuorumSet qSet;
case SCP_MESSAGE:
SCPEnvelope envelope;
case GET_SCP_STATE:
uint32 getSCPLedgerSeq; // ledger seq requested ; if 0, requests the latest
case SEND_MORE:
SendMore sendMoreMessage;
case SEND_MORE_EXTENDED:
SendMoreExtended sendMoreExtendedMessage;
// Pull mode
case FLOOD_ADVERT:
FloodAdvert floodAdvert;
case FLOOD_DEMAND:
FloodDemand floodDemand;
};
 * ```
 */
sealed class StellarMessage(val type: MessageType) : XdrElement {
    fun errorOrNull(): ErrorMsg? = if (this is ErrorMsg) this else null
    data class ErrorMsg(
        val error: Error,
    ) : StellarMessage(MessageType.ERROR_MSG) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            error.encode(stream)
        }
    }

    fun helloOrNull(): Hello? = if (this is Hello) this else null
    data class Hello(
        val hello: me.rahimklaber.stellar.base.xdr.Hello,
    ) : StellarMessage(MessageType.HELLO) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            hello.encode(stream)
        }
    }

    fun authOrNull(): Auth? = if (this is Auth) this else null
    data class Auth(
        val auth: me.rahimklaber.stellar.base.xdr.Auth,
    ) : StellarMessage(MessageType.AUTH) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            auth.encode(stream)
        }
    }

    fun dontHaveOrNull(): DontHave? = if (this is DontHave) this else null
    data class DontHave(
        val dontHave: me.rahimklaber.stellar.base.xdr.DontHave,
    ) : StellarMessage(MessageType.DONT_HAVE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            dontHave.encode(stream)
        }
    }

    fun peersOrNull(): Peers? = if (this is Peers) this else null
    data class Peers(
        val peers: List<PeerAddress>,
    ) : StellarMessage(MessageType.PEERS) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            val peersSize = peers.size
            stream.writeInt(peersSize)
            peers.encodeXdrElements(stream)
        }
    }

    fun txSetHashOrNull(): GetTxSet? = if (this is GetTxSet) this else null
    data class GetTxSet(
        val txSetHash: Uint256,
    ) : StellarMessage(MessageType.GET_TX_SET) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            txSetHash.encode(stream)
        }
    }

    fun txSetOrNull(): TxSet? = if (this is TxSet) this else null
    data class TxSet(
        val txSet: TransactionSet,
    ) : StellarMessage(MessageType.TX_SET) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            txSet.encode(stream)
        }
    }

    fun generalizedTxSetOrNull(): GeneralizedTxSet? = if (this is GeneralizedTxSet) this else null
    data class GeneralizedTxSet(
        val generalizedTxSet: GeneralizedTransactionSet,
    ) : StellarMessage(MessageType.GENERALIZED_TX_SET) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            generalizedTxSet.encode(stream)
        }
    }

    fun transactionOrNull(): Transaction? = if (this is Transaction) this else null
    data class Transaction(
        val transaction: TransactionEnvelope,
    ) : StellarMessage(MessageType.TRANSACTION) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            transaction.encode(stream)
        }
    }

    fun signedTimeSlicedSurveyRequestMessageOrNull(): TimeSlicedSurveyRequest? = if (this is TimeSlicedSurveyRequest) this else null
    data class TimeSlicedSurveyRequest(
        val signedTimeSlicedSurveyRequestMessage: SignedTimeSlicedSurveyRequestMessage,
    ) : StellarMessage(MessageType.TIME_SLICED_SURVEY_REQUEST) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            signedTimeSlicedSurveyRequestMessage.encode(stream)
        }
    }

    fun signedTimeSlicedSurveyResponseMessageOrNull(): TimeSlicedSurveyResponse? = if (this is TimeSlicedSurveyResponse) this else null
    data class TimeSlicedSurveyResponse(
        val signedTimeSlicedSurveyResponseMessage: SignedTimeSlicedSurveyResponseMessage,
    ) : StellarMessage(MessageType.TIME_SLICED_SURVEY_RESPONSE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            signedTimeSlicedSurveyResponseMessage.encode(stream)
        }
    }

    fun signedTimeSlicedSurveyStartCollectingMessageOrNull(): TimeSlicedSurveyStartCollecting? =
        if (this is TimeSlicedSurveyStartCollecting) this else null

    data class TimeSlicedSurveyStartCollecting(
        val signedTimeSlicedSurveyStartCollectingMessage: SignedTimeSlicedSurveyStartCollectingMessage,
    ) : StellarMessage(MessageType.TIME_SLICED_SURVEY_START_COLLECTING) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            signedTimeSlicedSurveyStartCollectingMessage.encode(stream)
        }
    }

    fun signedTimeSlicedSurveyStopCollectingMessageOrNull(): TimeSlicedSurveyStopCollecting? =
        if (this is TimeSlicedSurveyStopCollecting) this else null

    data class TimeSlicedSurveyStopCollecting(
        val signedTimeSlicedSurveyStopCollectingMessage: SignedTimeSlicedSurveyStopCollectingMessage,
    ) : StellarMessage(MessageType.TIME_SLICED_SURVEY_STOP_COLLECTING) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            signedTimeSlicedSurveyStopCollectingMessage.encode(stream)
        }
    }

    fun qSetHashOrNull(): GetScpQuorumset? = if (this is GetScpQuorumset) this else null
    data class GetScpQuorumset(
        val qSetHash: Uint256,
    ) : StellarMessage(MessageType.GET_SCP_QUORUMSET) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            qSetHash.encode(stream)
        }
    }

    fun qSetOrNull(): ScpQuorumset? = if (this is ScpQuorumset) this else null
    data class ScpQuorumset(
        val qSet: SCPQuorumSet,
    ) : StellarMessage(MessageType.SCP_QUORUMSET) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            qSet.encode(stream)
        }
    }

    fun envelopeOrNull(): ScpMessage? = if (this is ScpMessage) this else null
    data class ScpMessage(
        val envelope: SCPEnvelope,
    ) : StellarMessage(MessageType.SCP_MESSAGE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            envelope.encode(stream)
        }
    }

    fun getSCPLedgerSeqOrNull(): GetScpState? = if (this is GetScpState) this else null
    data class GetScpState(
        val getSCPLedgerSeq: Uint32,
    ) : StellarMessage(MessageType.GET_SCP_STATE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            getSCPLedgerSeq.encode(stream)
        }
    }

    fun sendMoreMessageOrNull(): SendMore? = if (this is SendMore) this else null
    data class SendMore(
        val sendMoreMessage: me.rahimklaber.stellar.base.xdr.SendMore,
    ) : StellarMessage(MessageType.SEND_MORE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            sendMoreMessage.encode(stream)
        }
    }

    fun sendMoreExtendedMessageOrNull(): SendMoreExtended? = if (this is SendMoreExtended) this else null
    data class SendMoreExtended(
        val sendMoreExtendedMessage: me.rahimklaber.stellar.base.xdr.SendMoreExtended,
    ) : StellarMessage(MessageType.SEND_MORE_EXTENDED) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            sendMoreExtendedMessage.encode(stream)
        }
    }

    fun floodAdvertOrNull(): FloodAdvert? = if (this is FloodAdvert) this else null
    data class FloodAdvert(
        val floodAdvert: me.rahimklaber.stellar.base.xdr.FloodAdvert,
    ) : StellarMessage(MessageType.FLOOD_ADVERT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            floodAdvert.encode(stream)
        }
    }

    fun floodDemandOrNull(): FloodDemand? = if (this is FloodDemand) this else null
    data class FloodDemand(
        val floodDemand: me.rahimklaber.stellar.base.xdr.FloodDemand,
    ) : StellarMessage(MessageType.FLOOD_DEMAND) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            floodDemand.encode(stream)
        }
    }

    companion object : XdrElementDecoder<StellarMessage> {
        override fun decode(stream: XdrInputStream): StellarMessage {
            return when (val type = MessageType.decode(stream)) {
                MessageType.ERROR_MSG -> {
                    val error = Error.decode(stream)
                    ErrorMsg(error)
                }

                MessageType.HELLO -> {
                    val hello = me.rahimklaber.stellar.base.xdr.Hello.decode(stream)
                    Hello(hello)
                }

                MessageType.AUTH -> {
                    val auth = me.rahimklaber.stellar.base.xdr.Auth.decode(stream)
                    Auth(auth)
                }

                MessageType.DONT_HAVE -> {
                    val dontHave = me.rahimklaber.stellar.base.xdr.DontHave.decode(stream)
                    DontHave(dontHave)
                }

                MessageType.PEERS -> {
                    val peersSize = stream.readInt()
                    val peers: List<PeerAddress> = decodeXdrElementsList(peersSize, stream, PeerAddress.decoder())
                    Peers(peers)
                }

                MessageType.GET_TX_SET -> {
                    val txSetHash = Uint256.decode(stream)
                    GetTxSet(txSetHash)
                }

                MessageType.TX_SET -> {
                    val txSet = TransactionSet.decode(stream)
                    TxSet(txSet)
                }

                MessageType.GENERALIZED_TX_SET -> {
                    val generalizedTxSet = GeneralizedTransactionSet.decode(stream)
                    GeneralizedTxSet(generalizedTxSet)
                }

                MessageType.TRANSACTION -> {
                    val transaction = TransactionEnvelope.decode(stream)
                    Transaction(transaction)
                }

                MessageType.TIME_SLICED_SURVEY_REQUEST -> {
                    val signedTimeSlicedSurveyRequestMessage = SignedTimeSlicedSurveyRequestMessage.decode(stream)
                    TimeSlicedSurveyRequest(signedTimeSlicedSurveyRequestMessage)
                }

                MessageType.TIME_SLICED_SURVEY_RESPONSE -> {
                    val signedTimeSlicedSurveyResponseMessage = SignedTimeSlicedSurveyResponseMessage.decode(stream)
                    TimeSlicedSurveyResponse(signedTimeSlicedSurveyResponseMessage)
                }

                MessageType.TIME_SLICED_SURVEY_START_COLLECTING -> {
                    val signedTimeSlicedSurveyStartCollectingMessage =
                        SignedTimeSlicedSurveyStartCollectingMessage.decode(stream)
                    TimeSlicedSurveyStartCollecting(signedTimeSlicedSurveyStartCollectingMessage)
                }

                MessageType.TIME_SLICED_SURVEY_STOP_COLLECTING -> {
                    val signedTimeSlicedSurveyStopCollectingMessage =
                        SignedTimeSlicedSurveyStopCollectingMessage.decode(stream)
                    TimeSlicedSurveyStopCollecting(signedTimeSlicedSurveyStopCollectingMessage)
                }

                MessageType.GET_SCP_QUORUMSET -> {
                    val qSetHash = Uint256.decode(stream)
                    GetScpQuorumset(qSetHash)
                }

                MessageType.SCP_QUORUMSET -> {
                    val qSet = SCPQuorumSet.decode(stream)
                    ScpQuorumset(qSet)
                }

                MessageType.SCP_MESSAGE -> {
                    val envelope = SCPEnvelope.decode(stream)
                    ScpMessage(envelope)
                }

                MessageType.GET_SCP_STATE -> {
                    val getSCPLedgerSeq = Uint32.decode(stream)
                    GetScpState(getSCPLedgerSeq)
                }

                MessageType.SEND_MORE -> {
                    val sendMoreMessage = me.rahimklaber.stellar.base.xdr.SendMore.decode(stream)
                    SendMore(sendMoreMessage)
                }

                MessageType.SEND_MORE_EXTENDED -> {
                    val sendMoreExtendedMessage = me.rahimklaber.stellar.base.xdr.SendMoreExtended.decode(stream)
                    SendMoreExtended(sendMoreExtendedMessage)
                }

                MessageType.FLOOD_ADVERT -> {
                    val floodAdvert = me.rahimklaber.stellar.base.xdr.FloodAdvert.decode(stream)
                    FloodAdvert(floodAdvert)
                }

                MessageType.FLOOD_DEMAND -> {
                    val floodDemand = me.rahimklaber.stellar.base.xdr.FloodDemand.decode(stream)
                    FloodDemand(floodDemand)
                }

                else -> throw IllegalArgumentException("unknown type: $type")
            }
        }
    }
}
