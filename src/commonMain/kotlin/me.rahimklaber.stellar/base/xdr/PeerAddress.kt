// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * PeerAddress's original definition in the XDR file is:
 * ```
 * struct PeerAddress
{
union switch (IPAddrType type)
{
case IPv4:
opaque ipv4[4];
case IPv6:
opaque ipv6[16];
}
ip;
uint32 port;
uint32 numFailures;
};
 * ```
 */
data class PeerAddress(
    val ip: PeerAddressIp,
    val port: Uint32,
    val numFailures: Uint32,
) : XdrElement {
    override fun encode(stream: XdrOutputStream) {
        ip.encode(stream)
        port.encode(stream)
        numFailures.encode(stream)
    }

    companion object : XdrElementDecoder<PeerAddress> {
        override fun decode(stream: XdrInputStream): PeerAddress {
            val ip = PeerAddressIp.decode(stream)
            val port = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val numFailures = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            return PeerAddress(
                ip,
                port,
                numFailures,
            )
        }
    }

    /**
     * PeerAddressIp's original definition in the XDR file is:
     * ```
     * union switch (IPAddrType type)
    {
    case IPv4:
    opaque ipv4[4];
    case IPv6:
    opaque ipv6[16];
    }
     * ```
     */
    sealed class PeerAddressIp(val type: IPAddrType) : XdrElement {
        fun ipv4OrNull(): Ipv4? = if (this is Ipv4) this else null
        data class Ipv4(
            val ipv4: ByteArray,
        ) : PeerAddressIp(IPAddrType.IPv4) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                stream.writeBytes(ipv4)
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) return true
                if (other == null || this::class != other::class) return false

                other as Ipv4

                return ipv4.contentEquals(other.ipv4)
            }

            override fun hashCode(): Int {
                return ipv4.contentHashCode()
            }
        }

        fun ipv6OrNull(): Ipv6? = if (this is Ipv6) this else null
        data class Ipv6(
            val ipv6: ByteArray,
        ) : PeerAddressIp(IPAddrType.IPv6) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                stream.writeBytes(ipv6)
            }

            override fun equals(other: Any?): Boolean {
                if (this === other) return true
                if (other == null || this::class != other::class) return false

                other as Ipv6

                return ipv6.contentEquals(other.ipv6)
            }

            override fun hashCode(): Int {
                return ipv6.contentHashCode()
            }
        }

        companion object : XdrElementDecoder<PeerAddressIp> {
            override fun decode(stream: XdrInputStream): PeerAddressIp {
                return when (val type = IPAddrType.decode(stream)) {
                    IPAddrType.IPv4 -> {
                        val ipv4Size = 4
                        val ipv4 = stream.readBytes(ipv4Size)
                        Ipv4(ipv4)
                    }

                    IPAddrType.IPv6 -> {
                        val ipv6Size = 16
                        val ipv6 = stream.readBytes(ipv6Size)
                        Ipv6(ipv6)
                    }

                    else -> throw IllegalArgumentException("unknown type: $type")
                }
            }
        }
    }
}
