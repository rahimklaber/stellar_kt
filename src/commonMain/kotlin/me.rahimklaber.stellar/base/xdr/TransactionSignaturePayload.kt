// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * TransactionSignaturePayload's original definition in the XDR file is:
 * ```
 * struct TransactionSignaturePayload
{
Hash networkId;
union switch (EnvelopeType type)
{
// Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0
case ENVELOPE_TYPE_TX:
Transaction tx;
case ENVELOPE_TYPE_TX_FEE_BUMP:
FeeBumpTransaction feeBump;
}
taggedTransaction;
};
 * ```
 */
data class TransactionSignaturePayload(
    val networkId: Hash,
    val taggedTransaction: TransactionSignaturePayloadTaggedTransaction,
) : XdrElement {
    override fun encode(stream: XdrOutputStream) {
        networkId.encode(stream)
        taggedTransaction.encode(stream)
    }

    companion object : XdrElementDecoder<TransactionSignaturePayload> {
        override fun decode(stream: XdrInputStream): TransactionSignaturePayload {
            val networkId = Hash.decode(stream)
            val taggedTransaction = TransactionSignaturePayloadTaggedTransaction.decode(stream)
            return TransactionSignaturePayload(
                networkId,
                taggedTransaction,
            )
        }
    }

    /**
     * TransactionSignaturePayloadTaggedTransaction's original definition in the XDR file is:
     * ```
     * union switch (EnvelopeType type)
    {
    // Backwards Compatibility: Use ENVELOPE_TYPE_TX to sign ENVELOPE_TYPE_TX_V0
    case ENVELOPE_TYPE_TX:
    Transaction tx;
    case ENVELOPE_TYPE_TX_FEE_BUMP:
    FeeBumpTransaction feeBump;
    }
     * ```
     */
    sealed class TransactionSignaturePayloadTaggedTransaction(val type: EnvelopeType) : XdrElement {
        fun txOrNull(): Tx? = if (this is Tx) this else null
        data class Tx(
            val tx: Transaction,
        ) : TransactionSignaturePayloadTaggedTransaction(EnvelopeType.ENVELOPE_TYPE_TX) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                tx.encode(stream)
            }
        }

        fun feeBumpOrNull(): TxFeeBump? = if (this is TxFeeBump) this else null
        data class TxFeeBump(
            val feeBump: FeeBumpTransaction,
        ) : TransactionSignaturePayloadTaggedTransaction(EnvelopeType.ENVELOPE_TYPE_TX_FEE_BUMP) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                feeBump.encode(stream)
            }
        }

        companion object : XdrElementDecoder<TransactionSignaturePayloadTaggedTransaction> {
            override fun decode(stream: XdrInputStream): TransactionSignaturePayloadTaggedTransaction {
                return when (val type = EnvelopeType.decode(stream)) {
                    EnvelopeType.ENVELOPE_TYPE_TX -> {
                        val tx = Transaction.decode(stream)
                        Tx(tx)
                    }

                    EnvelopeType.ENVELOPE_TYPE_TX_FEE_BUMP -> {
                        val feeBump = FeeBumpTransaction.decode(stream)
                        TxFeeBump(feeBump)
                    }

                    else -> throw IllegalArgumentException("unknown type: $type")
                }
            }
        }
    }
}
