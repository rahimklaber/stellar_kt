// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * SCError's original definition in the XDR file is:
 * ```
 * union SCError switch (SCErrorType type)
{
case SCE_CONTRACT:
uint32 contractCode;
case SCE_WASM_VM:
case SCE_CONTEXT:
case SCE_STORAGE:
case SCE_OBJECT:
case SCE_CRYPTO:
case SCE_EVENTS:
case SCE_BUDGET:
case SCE_VALUE:
case SCE_AUTH:
SCErrorCode code;
};
 * ```
 */
sealed class SCError(val type: SCErrorType) : XdrElement {
    fun contractCodeOrNull(): Contract? = if (this is Contract) this else null
    data class Contract(
        val contractCode: Uint32,
    ) : SCError(SCErrorType.SCE_CONTRACT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            contractCode.encode(stream)
        }
    }

    data class WasmVm(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_WASM_VM) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Context(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_CONTEXT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Storage(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_STORAGE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Object(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_OBJECT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Crypto(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_CRYPTO) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Events(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_EVENTS) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Budget(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_BUDGET) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Value(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_VALUE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    data class Auth(
        val code: SCErrorCode,
    ) : SCError(SCErrorType.SCE_AUTH) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            code.encode(stream)
        }
    }

    companion object : XdrElementDecoder<SCError> {
        override fun decode(stream: XdrInputStream): SCError {
            return when (val type = SCErrorType.decode(stream)) {
                SCErrorType.SCE_CONTRACT -> {
                    val contractCode = Uint32.decode(stream)
                    Contract(contractCode)
                }

                SCErrorType.SCE_WASM_VM -> {
                    val code = SCErrorCode.decode(stream)
                    WasmVm(code)
                }

                SCErrorType.SCE_CONTEXT -> {
                    val code = SCErrorCode.decode(stream)
                    Context(code)
                }

                SCErrorType.SCE_STORAGE -> {
                    val code = SCErrorCode.decode(stream)
                    Storage(code)
                }

                SCErrorType.SCE_OBJECT -> {
                    val code = SCErrorCode.decode(stream)
                    Object(code)
                }

                SCErrorType.SCE_CRYPTO -> {
                    val code = SCErrorCode.decode(stream)
                    Crypto(code)
                }

                SCErrorType.SCE_EVENTS -> {
                    val code = SCErrorCode.decode(stream)
                    Events(code)
                }

                SCErrorType.SCE_BUDGET -> {
                    val code = SCErrorCode.decode(stream)
                    Budget(code)
                }

                SCErrorType.SCE_VALUE -> {
                    val code = SCErrorCode.decode(stream)
                    Value(code)
                }

                SCErrorType.SCE_AUTH -> {
                    val code = SCErrorCode.decode(stream)
                    Auth(code)
                }

                else -> throw IllegalArgumentException("unknown type: $type")
            }
        }
    }
}
