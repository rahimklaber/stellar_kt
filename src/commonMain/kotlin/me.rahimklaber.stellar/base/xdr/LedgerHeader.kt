// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * LedgerHeader's original definition in the XDR file is:
 * ```
 * struct LedgerHeader
{
uint32 ledgerVersion;    // the protocol version of the ledger
Hash previousLedgerHash; // hash of the previous ledger header
StellarValue scpValue;   // what consensus agreed to
Hash txSetResultHash;    // the TransactionResultSet that led to this ledger
Hash bucketListHash;     // hash of the ledger state

uint32 ledgerSeq; // sequence number of this ledger

int64 totalCoins; // total number of stroops in existence.
// 10,000,000 stroops in 1 XLM

int64 feePool;       // fees burned since last inflation run
uint32 inflationSeq; // inflation sequence number

uint64 idPool; // last used global ID, used for generating objects

uint32 baseFee;     // base fee per operation in stroops
uint32 baseReserve; // account base reserve in stroops

uint32 maxTxSetSize; // maximum size a transaction set can be

Hash skipList[4]; // hashes of ledgers in the past. allows you to jump back
// in time without walking the chain back ledger by ledger
// each slot contains the oldest ledger that is mod of
// either 50  5000  50000 or 500000 depending on index
// skipList[0] mod(50), skipList[1] mod(5000), etc

// reserved for future use
union switch (int v)
{
case 0:
void;
case 1:
LedgerHeaderExtensionV1 v1;
}
ext;
};
 * ```
 */
data class LedgerHeader(
    val ledgerVersion: Uint32,
    val previousLedgerHash: Hash,
    val scpValue: StellarValue,
    val txSetResultHash: Hash,
    val bucketListHash: Hash,
    val ledgerSeq: Uint32,
    val totalCoins: Int64,
    val feePool: Int64,
    val inflationSeq: Uint32,
    val idPool: Uint64,
    val baseFee: Uint32,
    val baseReserve: Uint32,
    val maxTxSetSize: Uint32,
    val skipList: List<Hash>,
    val ext: LedgerHeaderExt,
) : XdrElement {
    override fun encode(stream: XdrOutputStream) {
        ledgerVersion.encode(stream)
        previousLedgerHash.encode(stream)
        scpValue.encode(stream)
        txSetResultHash.encode(stream)
        bucketListHash.encode(stream)
        ledgerSeq.encode(stream)
        totalCoins.encode(stream)
        feePool.encode(stream)
        inflationSeq.encode(stream)
        idPool.encode(stream)
        baseFee.encode(stream)
        baseReserve.encode(stream)
        maxTxSetSize.encode(stream)
        val skipListSize = skipList.size
        skipList.encodeXdrElements(stream)
        ext.encode(stream)
    }

    companion object : XdrElementDecoder<LedgerHeader> {
        override fun decode(stream: XdrInputStream): LedgerHeader {
            val ledgerVersion = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val previousLedgerHash = Hash.decode(stream)
            val scpValue = StellarValue.decode(stream)
            val txSetResultHash = Hash.decode(stream)
            val bucketListHash = Hash.decode(stream)
            val ledgerSeq = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val totalCoins = me.rahimklaber.stellar.base.xdr.Int64.decode(stream)
            val feePool = me.rahimklaber.stellar.base.xdr.Int64.decode(stream)
            val inflationSeq = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val idPool = me.rahimklaber.stellar.base.xdr.Uint64.decode(stream)
            val baseFee = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val baseReserve = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val maxTxSetSize = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val skipListSize = 4
            val skipList: List<Hash> = decodeXdrElementsList(skipListSize, stream, Hash.decoder())
            val ext = LedgerHeaderExt.decode(stream)
            return LedgerHeader(
                ledgerVersion,
                previousLedgerHash,
                scpValue,
                txSetResultHash,
                bucketListHash,
                ledgerSeq,
                totalCoins,
                feePool,
                inflationSeq,
                idPool,
                baseFee,
                baseReserve,
                maxTxSetSize,
                skipList,
                ext,
            )
        }
    }

    /**
     * LedgerHeaderExt's original definition in the XDR file is:
     * ```
     * union switch (int v)
    {
    case 0:
    void;
    case 1:
    LedgerHeaderExtensionV1 v1;
    }
     * ```
     */
    sealed class LedgerHeaderExt(val type: Int) : XdrElement {
        data object LedgerHeaderExtV0 : LedgerHeaderExt(0) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
            }
        }

        fun v1OrNull(): LedgerHeaderExtV1? = if (this is LedgerHeaderExtV1) this else null
        data class LedgerHeaderExtV1(
            val v1: LedgerHeaderExtensionV1,
        ) : LedgerHeaderExt(1) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                v1.encode(stream)
            }
        }

        companion object : XdrElementDecoder<LedgerHeaderExt> {
            override fun decode(stream: XdrInputStream): LedgerHeaderExt {
                return when (val type = Int.decode(stream)) {
                    0 -> LedgerHeaderExtV0
                    1 -> {
                        val v1 = LedgerHeaderExtensionV1.decode(stream)
                        LedgerHeaderExtV1(v1)
                    }

                    else -> throw IllegalArgumentException("unknown type: $type")
                }
            }
        }
    }
}
