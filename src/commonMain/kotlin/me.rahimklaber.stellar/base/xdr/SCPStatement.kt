// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * SCPStatement's original definition in the XDR file is:
 * ```
 * struct SCPStatement
{
NodeID nodeID;    // v
uint64 slotIndex; // i

union switch (SCPStatementType type)
{
case SCP_ST_PREPARE:
struct
{
Hash quorumSetHash;       // D
SCPBallot ballot;         // b
SCPBallot* prepared;      // p
SCPBallot* preparedPrime; // p'
uint32 nC;                // c.n
uint32 nH;                // h.n
} prepare;
case SCP_ST_CONFIRM:
struct
{
SCPBallot ballot;   // b
uint32 nPrepared;   // p.n
uint32 nCommit;     // c.n
uint32 nH;          // h.n
Hash quorumSetHash; // D
} confirm;
case SCP_ST_EXTERNALIZE:
struct
{
SCPBallot commit;         // c
uint32 nH;                // h.n
Hash commitQuorumSetHash; // D used before EXTERNALIZE
} externalize;
case SCP_ST_NOMINATE:
SCPNomination nominate;
}
pledges;
};
 * ```
 */
data class SCPStatement(
    val nodeID: NodeID,
    val slotIndex: Uint64,
    val pledges: SCPStatementPledges,
) : XdrElement {
    override fun encode(stream: XdrOutputStream) {
        nodeID.encode(stream)
        slotIndex.encode(stream)
        pledges.encode(stream)
    }

    companion object : XdrElementDecoder<SCPStatement> {
        override fun decode(stream: XdrInputStream): SCPStatement {
            val nodeID = NodeID.decode(stream)
            val slotIndex = me.rahimklaber.stellar.base.xdr.Uint64.decode(stream)
            val pledges = SCPStatementPledges.decode(stream)
            return SCPStatement(
                nodeID,
                slotIndex,
                pledges,
            )
        }
    }

    /**
     * SCPStatementPledges's original definition in the XDR file is:
     * ```
     * union switch (SCPStatementType type)
    {
    case SCP_ST_PREPARE:
    struct
    {
    Hash quorumSetHash;       // D
    SCPBallot ballot;         // b
    SCPBallot* prepared;      // p
    SCPBallot* preparedPrime; // p'
    uint32 nC;                // c.n
    uint32 nH;                // h.n
    } prepare;
    case SCP_ST_CONFIRM:
    struct
    {
    SCPBallot ballot;   // b
    uint32 nPrepared;   // p.n
    uint32 nCommit;     // c.n
    uint32 nH;          // h.n
    Hash quorumSetHash; // D
    } confirm;
    case SCP_ST_EXTERNALIZE:
    struct
    {
    SCPBallot commit;         // c
    uint32 nH;                // h.n
    Hash commitQuorumSetHash; // D used before EXTERNALIZE
    } externalize;
    case SCP_ST_NOMINATE:
    SCPNomination nominate;
    }
     * ```
     */
    sealed class SCPStatementPledges(val type: SCPStatementType) : XdrElement {
        fun prepareOrNull(): ScpStPrepare? = if (this is ScpStPrepare) this else null
        data class ScpStPrepare(
            val prepare: SCPStatementPrepare,
        ) : SCPStatementPledges(SCPStatementType.SCP_ST_PREPARE) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                prepare.encode(stream)
            }
        }

        fun confirmOrNull(): ScpStConfirm? = if (this is ScpStConfirm) this else null
        data class ScpStConfirm(
            val confirm: SCPStatementConfirm,
        ) : SCPStatementPledges(SCPStatementType.SCP_ST_CONFIRM) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                confirm.encode(stream)
            }
        }

        fun externalizeOrNull(): ScpStExternalize? = if (this is ScpStExternalize) this else null
        data class ScpStExternalize(
            val externalize: SCPStatementExternalize,
        ) : SCPStatementPledges(SCPStatementType.SCP_ST_EXTERNALIZE) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                externalize.encode(stream)
            }
        }

        fun nominateOrNull(): ScpStNominate? = if (this is ScpStNominate) this else null
        data class ScpStNominate(
            val nominate: SCPNomination,
        ) : SCPStatementPledges(SCPStatementType.SCP_ST_NOMINATE) {
            override fun encode(stream: XdrOutputStream) {
                type.encode(stream)
                nominate.encode(stream)
            }
        }

        companion object : XdrElementDecoder<SCPStatementPledges> {
            override fun decode(stream: XdrInputStream): SCPStatementPledges {
                return when (val type = SCPStatementType.decode(stream)) {
                    SCPStatementType.SCP_ST_PREPARE -> {
                        val prepare = SCPStatementPrepare.decode(stream)
                        ScpStPrepare(prepare)
                    }

                    SCPStatementType.SCP_ST_CONFIRM -> {
                        val confirm = SCPStatementConfirm.decode(stream)
                        ScpStConfirm(confirm)
                    }

                    SCPStatementType.SCP_ST_EXTERNALIZE -> {
                        val externalize = SCPStatementExternalize.decode(stream)
                        ScpStExternalize(externalize)
                    }

                    SCPStatementType.SCP_ST_NOMINATE -> {
                        val nominate = SCPNomination.decode(stream)
                        ScpStNominate(nominate)
                    }

                    else -> throw IllegalArgumentException("unknown type: $type")
                }
            }
        }

        /**
         * SCPStatementPrepare's original definition in the XDR file is:
         * ```
         * struct
        {
        Hash quorumSetHash;       // D
        SCPBallot ballot;         // b
        SCPBallot* prepared;      // p
        SCPBallot* preparedPrime; // p'
        uint32 nC;                // c.n
        uint32 nH;                // h.n
        }
         * ```
         */
        data class SCPStatementPrepare(
            val quorumSetHash: Hash,
            val ballot: SCPBallot,
            val prepared: SCPBallot?,
            val preparedPrime: SCPBallot?,
            val nC: Uint32,
            val nH: Uint32,
        ) : XdrElement {
            override fun encode(stream: XdrOutputStream) {
                quorumSetHash.encode(stream)
                ballot.encode(stream)
                if (prepared != null) {
                    stream.writeInt(1)
                    prepared.encode(stream)
                } else {
                    stream.writeInt(0)
                }
                if (preparedPrime != null) {
                    stream.writeInt(1)
                    preparedPrime.encode(stream)
                } else {
                    stream.writeInt(0)
                }
                nC.encode(stream)
                nH.encode(stream)
            }

            companion object : XdrElementDecoder<SCPStatementPrepare> {
                override fun decode(stream: XdrInputStream): SCPStatementPrepare {
                    val quorumSetHash = Hash.decode(stream)
                    val ballot = SCPBallot.decode(stream)
                    val preparedPresent = stream.readInt()
                    val prepared = if (preparedPresent != 0) {
                        SCPBallot.decode(stream)
                    } else {
                        null
                    }
                    val preparedPrimePresent = stream.readInt()
                    val preparedPrime = if (preparedPrimePresent != 0) {
                        SCPBallot.decode(stream)
                    } else {
                        null
                    }
                    val nC = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
                    val nH = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
                    return SCPStatementPrepare(
                        quorumSetHash,
                        ballot,
                        prepared,
                        preparedPrime,
                        nC,
                        nH,
                    )
                }
            }

        }

        /**
         * SCPStatementConfirm's original definition in the XDR file is:
         * ```
         * struct
        {
        SCPBallot ballot;   // b
        uint32 nPrepared;   // p.n
        uint32 nCommit;     // c.n
        uint32 nH;          // h.n
        Hash quorumSetHash; // D
        }
         * ```
         */
        data class SCPStatementConfirm(
            val ballot: SCPBallot,
            val nPrepared: Uint32,
            val nCommit: Uint32,
            val nH: Uint32,
            val quorumSetHash: Hash,
        ) : XdrElement {
            override fun encode(stream: XdrOutputStream) {
                ballot.encode(stream)
                nPrepared.encode(stream)
                nCommit.encode(stream)
                nH.encode(stream)
                quorumSetHash.encode(stream)
            }

            companion object : XdrElementDecoder<SCPStatementConfirm> {
                override fun decode(stream: XdrInputStream): SCPStatementConfirm {
                    val ballot = SCPBallot.decode(stream)
                    val nPrepared = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
                    val nCommit = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
                    val nH = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
                    val quorumSetHash = Hash.decode(stream)
                    return SCPStatementConfirm(
                        ballot,
                        nPrepared,
                        nCommit,
                        nH,
                        quorumSetHash,
                    )
                }
            }

        }

        /**
         * SCPStatementExternalize's original definition in the XDR file is:
         * ```
         * struct
        {
        SCPBallot commit;         // c
        uint32 nH;                // h.n
        Hash commitQuorumSetHash; // D used before EXTERNALIZE
        }
         * ```
         */
        data class SCPStatementExternalize(
            val commit: SCPBallot,
            val nH: Uint32,
            val commitQuorumSetHash: Hash,
        ) : XdrElement {
            override fun encode(stream: XdrOutputStream) {
                commit.encode(stream)
                nH.encode(stream)
                commitQuorumSetHash.encode(stream)
            }

            companion object : XdrElementDecoder<SCPStatementExternalize> {
                override fun decode(stream: XdrInputStream): SCPStatementExternalize {
                    val commit = SCPBallot.decode(stream)
                    val nH = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
                    val commitQuorumSetHash = Hash.decode(stream)
                    return SCPStatementExternalize(
                        commit,
                        nH,
                        commitQuorumSetHash,
                    )
                }
            }

        }
    }
}
