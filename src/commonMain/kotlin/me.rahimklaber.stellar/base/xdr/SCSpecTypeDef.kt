// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * SCSpecTypeDef's original definition in the XDR file is:
 * ```
 * union SCSpecTypeDef switch (SCSpecType type)
{
case SC_SPEC_TYPE_VAL:
case SC_SPEC_TYPE_BOOL:
case SC_SPEC_TYPE_VOID:
case SC_SPEC_TYPE_ERROR:
case SC_SPEC_TYPE_U32:
case SC_SPEC_TYPE_I32:
case SC_SPEC_TYPE_U64:
case SC_SPEC_TYPE_I64:
case SC_SPEC_TYPE_TIMEPOINT:
case SC_SPEC_TYPE_DURATION:
case SC_SPEC_TYPE_U128:
case SC_SPEC_TYPE_I128:
case SC_SPEC_TYPE_U256:
case SC_SPEC_TYPE_I256:
case SC_SPEC_TYPE_BYTES:
case SC_SPEC_TYPE_STRING:
case SC_SPEC_TYPE_SYMBOL:
case SC_SPEC_TYPE_ADDRESS:
void;
case SC_SPEC_TYPE_OPTION:
SCSpecTypeOption option;
case SC_SPEC_TYPE_RESULT:
SCSpecTypeResult result;
case SC_SPEC_TYPE_VEC:
SCSpecTypeVec vec;
case SC_SPEC_TYPE_MAP:
SCSpecTypeMap map;
case SC_SPEC_TYPE_TUPLE:
SCSpecTypeTuple tuple;
case SC_SPEC_TYPE_BYTES_N:
SCSpecTypeBytesN bytesN;
case SC_SPEC_TYPE_UDT:
SCSpecTypeUDT udt;
};
 * ```
 */
sealed class SCSpecTypeDef(val type: SCSpecType) : XdrElement {
    data object Val : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_VAL) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Bool : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_BOOL) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Void : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_VOID) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Error : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_ERROR) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object U32 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_U32) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object I32 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_I32) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object U64 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_U64) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object I64 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_I64) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Timepoint : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_TIMEPOINT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Duration : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_DURATION) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object U128 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_U128) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object I128 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_I128) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object U256 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_U256) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object I256 : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_I256) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Bytes : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_BYTES) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object String : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_STRING) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Symbol : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_SYMBOL) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    data object Address : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_ADDRESS) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
        }
    }

    fun optionOrNull(): Option? = if (this is Option) this else null
    data class Option(
        val option: SCSpecTypeOption,
    ) : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_OPTION) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            option.encode(stream)
        }
    }

    fun resultOrNull(): Result? = if (this is Result) this else null
    data class Result(
        val result: SCSpecTypeResult,
    ) : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_RESULT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            result.encode(stream)
        }
    }

    fun vecOrNull(): Vec? = if (this is Vec) this else null
    data class Vec(
        val vec: SCSpecTypeVec,
    ) : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_VEC) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            vec.encode(stream)
        }
    }

    fun mapOrNull(): Map? = if (this is Map) this else null
    data class Map(
        val map: SCSpecTypeMap,
    ) : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_MAP) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            map.encode(stream)
        }
    }

    fun tupleOrNull(): Tuple? = if (this is Tuple) this else null
    data class Tuple(
        val tuple: SCSpecTypeTuple,
    ) : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_TUPLE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            tuple.encode(stream)
        }
    }

    fun bytesNOrNull(): BytesN? = if (this is BytesN) this else null
    data class BytesN(
        val bytesN: SCSpecTypeBytesN,
    ) : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_BYTES_N) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            bytesN.encode(stream)
        }
    }

    fun udtOrNull(): Udt? = if (this is Udt) this else null
    data class Udt(
        val udt: SCSpecTypeUDT,
    ) : SCSpecTypeDef(SCSpecType.SC_SPEC_TYPE_UDT) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            udt.encode(stream)
        }
    }

    companion object : XdrElementDecoder<SCSpecTypeDef> {
        override fun decode(stream: XdrInputStream): SCSpecTypeDef {
            return when (val type = SCSpecType.decode(stream)) {
                SCSpecType.SC_SPEC_TYPE_VAL -> Val
                SCSpecType.SC_SPEC_TYPE_BOOL -> Bool
                SCSpecType.SC_SPEC_TYPE_VOID -> Void
                SCSpecType.SC_SPEC_TYPE_ERROR -> Error
                SCSpecType.SC_SPEC_TYPE_U32 -> U32
                SCSpecType.SC_SPEC_TYPE_I32 -> I32
                SCSpecType.SC_SPEC_TYPE_U64 -> U64
                SCSpecType.SC_SPEC_TYPE_I64 -> I64
                SCSpecType.SC_SPEC_TYPE_TIMEPOINT -> Timepoint
                SCSpecType.SC_SPEC_TYPE_DURATION -> Duration
                SCSpecType.SC_SPEC_TYPE_U128 -> U128
                SCSpecType.SC_SPEC_TYPE_I128 -> I128
                SCSpecType.SC_SPEC_TYPE_U256 -> U256
                SCSpecType.SC_SPEC_TYPE_I256 -> I256
                SCSpecType.SC_SPEC_TYPE_BYTES -> Bytes
                SCSpecType.SC_SPEC_TYPE_STRING -> String
                SCSpecType.SC_SPEC_TYPE_SYMBOL -> Symbol
                SCSpecType.SC_SPEC_TYPE_ADDRESS -> Address
                SCSpecType.SC_SPEC_TYPE_OPTION -> {
                    val option = SCSpecTypeOption.decode(stream)
                    Option(option)
                }

                SCSpecType.SC_SPEC_TYPE_RESULT -> {
                    val result = SCSpecTypeResult.decode(stream)
                    Result(result)
                }

                SCSpecType.SC_SPEC_TYPE_VEC -> {
                    val vec = SCSpecTypeVec.decode(stream)
                    Vec(vec)
                }

                SCSpecType.SC_SPEC_TYPE_MAP -> {
                    val map = SCSpecTypeMap.decode(stream)
                    Map(map)
                }

                SCSpecType.SC_SPEC_TYPE_TUPLE -> {
                    val tuple = SCSpecTypeTuple.decode(stream)
                    Tuple(tuple)
                }

                SCSpecType.SC_SPEC_TYPE_BYTES_N -> {
                    val bytesN = SCSpecTypeBytesN.decode(stream)
                    BytesN(bytesN)
                }

                SCSpecType.SC_SPEC_TYPE_UDT -> {
                    val udt = SCSpecTypeUDT.decode(stream)
                    Udt(udt)
                }

                else -> throw IllegalArgumentException("unknown type: $type")
            }
        }
    }
}
