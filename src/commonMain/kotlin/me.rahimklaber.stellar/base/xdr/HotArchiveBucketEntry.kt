// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * HotArchiveBucketEntry's original definition in the XDR file is:
 * ```
 * union HotArchiveBucketEntry switch (HotArchiveBucketEntryType type)
{
case HOT_ARCHIVE_ARCHIVED:
LedgerEntry archivedEntry;

case HOT_ARCHIVE_LIVE:
case HOT_ARCHIVE_DELETED:
LedgerKey key;
case HOT_ARCHIVE_METAENTRY:
BucketMetadata metaEntry;
};
 * ```
 */
sealed class HotArchiveBucketEntry(val type: HotArchiveBucketEntryType) : XdrElement {
    fun archivedEntryOrNull(): HotArchiveArchived? = if (this is HotArchiveArchived) this else null
    data class HotArchiveArchived(
        val archivedEntry: LedgerEntry,
    ) : HotArchiveBucketEntry(HotArchiveBucketEntryType.HOT_ARCHIVE_ARCHIVED) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            archivedEntry.encode(stream)
        }
    }

    data class HotArchiveLive(
        val key: LedgerKey,
    ) : HotArchiveBucketEntry(HotArchiveBucketEntryType.HOT_ARCHIVE_LIVE) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            key.encode(stream)
        }
    }

    data class HotArchiveDeleted(
        val key: LedgerKey,
    ) : HotArchiveBucketEntry(HotArchiveBucketEntryType.HOT_ARCHIVE_DELETED) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            key.encode(stream)
        }
    }

    fun metaEntryOrNull(): HotArchiveMetaentry? = if (this is HotArchiveMetaentry) this else null
    data class HotArchiveMetaentry(
        val metaEntry: BucketMetadata,
    ) : HotArchiveBucketEntry(HotArchiveBucketEntryType.HOT_ARCHIVE_METAENTRY) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            metaEntry.encode(stream)
        }
    }

    companion object : XdrElementDecoder<HotArchiveBucketEntry> {
        override fun decode(stream: XdrInputStream): HotArchiveBucketEntry {
            return when (val type = HotArchiveBucketEntryType.decode(stream)) {
                HotArchiveBucketEntryType.HOT_ARCHIVE_ARCHIVED -> {
                    val archivedEntry = LedgerEntry.decode(stream)
                    HotArchiveArchived(archivedEntry)
                }

                HotArchiveBucketEntryType.HOT_ARCHIVE_LIVE -> {
                    val key = LedgerKey.decode(stream)
                    HotArchiveLive(key)
                }

                HotArchiveBucketEntryType.HOT_ARCHIVE_DELETED -> {
                    val key = LedgerKey.decode(stream)
                    HotArchiveDeleted(key)
                }

                HotArchiveBucketEntryType.HOT_ARCHIVE_METAENTRY -> {
                    val metaEntry = BucketMetadata.decode(stream)
                    HotArchiveMetaentry(metaEntry)
                }

                else -> throw IllegalArgumentException("unknown type: $type")
            }
        }
    }
}
