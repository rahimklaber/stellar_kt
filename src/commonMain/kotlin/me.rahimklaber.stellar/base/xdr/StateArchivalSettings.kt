// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * StateArchivalSettings's original definition in the XDR file is:
 * ```
 * struct StateArchivalSettings {
uint32 maxEntryTTL;
uint32 minTemporaryTTL;
uint32 minPersistentTTL;

// rent_fee = wfee_rate_average / rent_rate_denominator_for_type
int64 persistentRentRateDenominator;
int64 tempRentRateDenominator;

// max number of entries that emit archival meta in a single ledger
uint32 maxEntriesToArchive;

// Number of snapshots to use when calculating average BucketList size
uint32 bucketListSizeWindowSampleSize;

// How often to sample the BucketList size for the average, in ledgers
uint32 bucketListWindowSamplePeriod;

// Maximum number of bytes that we scan for eviction per ledger
uint32 evictionScanSize;

// Lowest BucketList level to be scanned to evict entries
uint32 startingEvictionScanLevel;
};
 * ```
 */
data class StateArchivalSettings(
    val maxEntryTTL: Uint32,
    val minTemporaryTTL: Uint32,
    val minPersistentTTL: Uint32,
    val persistentRentRateDenominator: Int64,
    val tempRentRateDenominator: Int64,
    val maxEntriesToArchive: Uint32,
    val bucketListSizeWindowSampleSize: Uint32,
    val bucketListWindowSamplePeriod: Uint32,
    val evictionScanSize: Uint32,
    val startingEvictionScanLevel: Uint32,
) : XdrElement {
    override fun encode(stream: XdrOutputStream) {
        maxEntryTTL.encode(stream)
        minTemporaryTTL.encode(stream)
        minPersistentTTL.encode(stream)
        persistentRentRateDenominator.encode(stream)
        tempRentRateDenominator.encode(stream)
        maxEntriesToArchive.encode(stream)
        bucketListSizeWindowSampleSize.encode(stream)
        bucketListWindowSamplePeriod.encode(stream)
        evictionScanSize.encode(stream)
        startingEvictionScanLevel.encode(stream)
    }

    companion object : XdrElementDecoder<StateArchivalSettings> {
        override fun decode(stream: XdrInputStream): StateArchivalSettings {
            val maxEntryTTL = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val minTemporaryTTL = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val minPersistentTTL = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val persistentRentRateDenominator = me.rahimklaber.stellar.base.xdr.Int64.decode(stream)
            val tempRentRateDenominator = me.rahimklaber.stellar.base.xdr.Int64.decode(stream)
            val maxEntriesToArchive = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val bucketListSizeWindowSampleSize = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val bucketListWindowSamplePeriod = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val evictionScanSize = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val startingEvictionScanLevel = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            return StateArchivalSettings(
                maxEntryTTL,
                minTemporaryTTL,
                minPersistentTTL,
                persistentRentRateDenominator,
                tempRentRateDenominator,
                maxEntriesToArchive,
                bucketListSizeWindowSampleSize,
                bucketListWindowSamplePeriod,
                evictionScanSize,
                startingEvictionScanLevel,
            )
        }
    }
}
