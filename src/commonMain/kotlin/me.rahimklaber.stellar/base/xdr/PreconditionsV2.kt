// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * PreconditionsV2's original definition in the XDR file is:
 * ```
 * struct PreconditionsV2
{
TimeBounds* timeBounds;

// Transaction only valid for ledger numbers n such that
// minLedger <= n < maxLedger (if maxLedger == 0, then
// only minLedger is checked)
LedgerBounds* ledgerBounds;

// If NULL, only valid when sourceAccount's sequence number
// is seqNum - 1.  Otherwise, valid when sourceAccount's
// sequence number n satisfies minSeqNum <= n < tx.seqNum.
// Note that after execution the account's sequence number
// is always raised to tx.seqNum, and a transaction is not
// valid if tx.seqNum is too high to ensure replay protection.
SequenceNumber* minSeqNum;

// For the transaction to be valid, the current ledger time must
// be at least minSeqAge greater than sourceAccount's seqTime.
Duration minSeqAge;

// For the transaction to be valid, the current ledger number
// must be at least minSeqLedgerGap greater than sourceAccount's
// seqLedger.
uint32 minSeqLedgerGap;

// For the transaction to be valid, there must be a signature
// corresponding to every Signer in this array, even if the
// signature is not otherwise required by the sourceAccount or
// operations.
SignerKey extraSigners<2>;
};
 * ```
 */
data class PreconditionsV2(
    val timeBounds: TimeBounds?,
    val ledgerBounds: LedgerBounds?,
    val minSeqNum: SequenceNumber?,
    val minSeqAge: Duration,
    val minSeqLedgerGap: Uint32,
    val extraSigners: List<SignerKey>,
) : XdrElement {
    override fun encode(stream: XdrOutputStream) {
        if (timeBounds != null) {
            stream.writeInt(1)
            timeBounds.encode(stream)
        } else {
            stream.writeInt(0)
        }
        if (ledgerBounds != null) {
            stream.writeInt(1)
            ledgerBounds.encode(stream)
        } else {
            stream.writeInt(0)
        }
        if (minSeqNum != null) {
            stream.writeInt(1)
            minSeqNum.encode(stream)
        } else {
            stream.writeInt(0)
        }
        minSeqAge.encode(stream)
        minSeqLedgerGap.encode(stream)
        val extraSignersSize = extraSigners.size
        stream.writeInt(extraSignersSize)
        extraSigners.encodeXdrElements(stream)
    }

    companion object : XdrElementDecoder<PreconditionsV2> {
        override fun decode(stream: XdrInputStream): PreconditionsV2 {
            val timeBoundsPresent = stream.readInt()
            val timeBounds = if (timeBoundsPresent != 0) {
                TimeBounds.decode(stream)
            } else {
                null
            }
            val ledgerBoundsPresent = stream.readInt()
            val ledgerBounds = if (ledgerBoundsPresent != 0) {
                LedgerBounds.decode(stream)
            } else {
                null
            }
            val minSeqNumPresent = stream.readInt()
            val minSeqNum = if (minSeqNumPresent != 0) {
                SequenceNumber.decode(stream)
            } else {
                null
            }
            val minSeqAge = Duration.decode(stream)
            val minSeqLedgerGap = me.rahimklaber.stellar.base.xdr.Uint32.decode(stream)
            val extraSignersSize = stream.readInt()
            val extraSigners: List<SignerKey> = decodeXdrElementsList(extraSignersSize, stream, SignerKey.decoder())
            return PreconditionsV2(
                timeBounds,
                ledgerBounds,
                minSeqNum,
                minSeqAge,
                minSeqLedgerGap,
                extraSigners,
            )
        }
    }
}
