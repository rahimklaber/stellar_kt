// Automatically generated by xdrgen
// DO NOT EDIT or your changes may be overwritten

package me.rahimklaber.stellar.base.xdr


/**
 * SignerKey's original definition in the XDR file is:
 * ```
 * union SignerKey switch (SignerKeyType type)
{
case SIGNER_KEY_TYPE_ED25519:
uint256 ed25519;
case SIGNER_KEY_TYPE_PRE_AUTH_TX:
/* SHA-256 Hash of TransactionSignaturePayload structure */
uint256 preAuthTx;
case SIGNER_KEY_TYPE_HASH_X:
/* Hash of random 256 bit preimage X */
uint256 hashX;
case SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD:
struct
{
/* Public key that must sign the payload. */
uint256 ed25519;
/* Payload to be raw signed by ed25519. */
opaque payload<64>;
} ed25519SignedPayload;
};
 * ```
 */
sealed class SignerKey(val type: SignerKeyType) : XdrElement {
    fun ed25519OrNull(): Ed25519? = if (this is Ed25519) this else null
    data class Ed25519(
        val ed25519: Uint256,
    ) : SignerKey(SignerKeyType.SIGNER_KEY_TYPE_ED25519) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            ed25519.encode(stream)
        }
    }

    fun preAuthTxOrNull(): PreAuthTx? = if (this is PreAuthTx) this else null
    data class PreAuthTx(
        val preAuthTx: Uint256,
    ) : SignerKey(SignerKeyType.SIGNER_KEY_TYPE_PRE_AUTH_TX) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            preAuthTx.encode(stream)
        }
    }

    fun hashXOrNull(): HashX? = if (this is HashX) this else null
    data class HashX(
        val hashX: Uint256,
    ) : SignerKey(SignerKeyType.SIGNER_KEY_TYPE_HASH_X) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            hashX.encode(stream)
        }
    }

    fun ed25519SignedPayloadOrNull(): Ed25519SignedPayload? = if (this is Ed25519SignedPayload) this else null
    data class Ed25519SignedPayload(
        val ed25519SignedPayload: SignerKeyEd25519SignedPayload,
    ) : SignerKey(SignerKeyType.SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD) {
        override fun encode(stream: XdrOutputStream) {
            type.encode(stream)
            ed25519SignedPayload.encode(stream)
        }
    }

    companion object : XdrElementDecoder<SignerKey> {
        override fun decode(stream: XdrInputStream): SignerKey {
            return when (val type = SignerKeyType.decode(stream)) {
                SignerKeyType.SIGNER_KEY_TYPE_ED25519 -> {
                    val ed25519 = Uint256.decode(stream)
                    Ed25519(ed25519)
                }

                SignerKeyType.SIGNER_KEY_TYPE_PRE_AUTH_TX -> {
                    val preAuthTx = Uint256.decode(stream)
                    PreAuthTx(preAuthTx)
                }

                SignerKeyType.SIGNER_KEY_TYPE_HASH_X -> {
                    val hashX = Uint256.decode(stream)
                    HashX(hashX)
                }

                SignerKeyType.SIGNER_KEY_TYPE_ED25519_SIGNED_PAYLOAD -> {
                    val ed25519SignedPayload = SignerKeyEd25519SignedPayload.decode(stream)
                    Ed25519SignedPayload(ed25519SignedPayload)
                }

                else -> throw IllegalArgumentException("unknown type: $type")
            }
        }
    }

    /**
     * SignerKeyEd25519SignedPayload's original definition in the XDR file is:
     * ```
     * struct
    {
    /* Public key that must sign the payload. */
    uint256 ed25519;
    /* Payload to be raw signed by ed25519. */
    opaque payload<64>;
    }
     * ```
     */
    data class SignerKeyEd25519SignedPayload(
        val ed25519: Uint256,
        val payload: ByteArray,
    ) : XdrElement {
        override fun encode(stream: XdrOutputStream) {
            ed25519.encode(stream)
            val payloadSize = payload.size
            stream.writeInt(payloadSize)
            stream.writeBytes(payload)
        }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other == null || this::class != other::class) return false

            other as SignerKeyEd25519SignedPayload

            if (ed25519 != other.ed25519) return false
            if (!payload.contentEquals(other.payload)) return false

            return true
        }

        override fun hashCode(): Int {
            var result = ed25519.hashCode()
            result = 31 * result + payload.contentHashCode()
            return result
        }

        companion object : XdrElementDecoder<SignerKeyEd25519SignedPayload> {
            override fun decode(stream: XdrInputStream): SignerKeyEd25519SignedPayload {
                val ed25519 = Uint256.decode(stream)
                val payloadSize = stream.readInt()
                val payload = stream.readBytes(payloadSize)
                return SignerKeyEd25519SignedPayload(
                    ed25519,
                    payload,
                )
            }
        }

    }
}
